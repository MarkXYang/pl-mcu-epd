Texas Instruments – MSP430
==========================

This section provides information specific to deploying the code on the reference MSP430 platform
hardware available from Plastic Logic. This provides a supported, stable environment in which to
investigate the behaviour of the code before moving on to a customised platform.

MSP430 - Getting Started
------------------------

Importing the project
---------------------
The project code needs to be imported into the Code Composer Studio (CCS) IDE in order to build it using
the following steps:

1. Project | Import Existing CCS Eclipse Project
2. “Select Search-directory:” and use the Browse button to navigate to the folder created when the distribution archive was unzipped.
3. In the “Discovered projects” window select the uc-epson project
4. Click Finish and the project will be imported into the IDE
5. Click on uc-epson [Active - Debug] in the Project Explorer Window
6. Project | Build All
   This will rebuild the code. Note that there is one error and one warning. This is expected. The
   warning is in the Fat file-system code and can be ignored. The error indicates that the code has not
   yet been correctly configured.
	
Configuring the code
--------------------
The code is configured at compile time to define the type of display interface board and display-type that it
will be driving.

At the top of main.c (shown in the Project Explorer window with a red cross) are several macros.

1. Select a display interface board type: define one of PLAT_CUCKOO, PLAT_RAVEN, PLAT_Z13, PLAT_Z6 or PLAT_Z7 to be 1
2. Select a display type to be driven by uncommenting the appropriate CONFIG_DISPLAY_TYPE macro. The available options are shown directly below the corresponding PLAT_* macros. The Cuckoo and Raven boards can only drive a single display type so no display needs to be selected.
3. If the I2C interface is to be provided by the Epson controller define CONFIG_I2C_ON_EPSON to be 1. The Cuckoo and Raven boards have this predefined by the board design so this macro will be ignored. 0 is the safe default.

Rebuild the code (Project | Build All (or Control-B)). The error in main.c will go away and the code is now
configured to drive the selected board and display type.

Download and Run
----------------
Plug the USB MSP430-FET430UIF programmer into the JTAG programming port on the MSP430 board.
Turn on the 5V supply to the Ruddock2 and select “Run | Debug” in the IDE.

The first time the IDE downloads the code the “Ultra-Low-Power Advisor” may appear warning about
possible power optimisations. Select “Do not show this again” and proceed.

The code will be downloaded into the MSP430 and the IDE will stop at the entry to main().

To run the code press F8 (or the green go arrow in the debugger tool bar). The code will start and the
display should initialise and start to cycle through the images appropriate for the type of display selected.

Debug messages will be displayed in the Debugger Console in the IDE.

Once the MSP430 has been programmed the slideshow will run automatically when power is applied to the
board (unless the debugger is attached holding it in reset).

Target Processor
----------------
The code is targeted to the MSP430F5438A controller. This part was chosen because it gave plenty of
resources to work with during early development and was compatible with the MSP-EXP430F5438
development board from TI.

Further development has refined the resources required and the MSP430F5310 would have sufficient
resources to drive a display with similar performance while using only 48 pins.

Parrot - MSP430 Processor Board
-------------------------------
The Parrot board docks with the Ruddock2 motherboard to provide access to the display interfaces. It has
the same form factor and connector pin out as a BeagleBone allowing the processors to be easily swapped
for evaluation or development work.

The board has the following features:

1. MSP430F5438A, clocked at 20MHz
2. A 32KHz oscillator for low power operation
3. micro SD card socket
4. On-board reset switch
5. JTAG programming header (an adapter may be required to mate with the MSP-FET430UIF programmer)
6. All 100 processor pins available on debug headers
7. On-board power regulation and power socket
8. The board has 1 LED for power good and another connected to a pin on the processor for status indication.
9. Provision for an SPI daisy-chain of MSP430 boards using 2 SPI channels (upstream and downstream)

If required the board can be used as a standalone development platform be powered from the JTAG-FET
programmer.

Toolchains
----------

Code Composer Studio
^^^^^^^^^^^^^^^^^^^^
This has been used extensively during development of the code in conjunction with the MSP-FET430UIF
USB/JTAG programmer. Both have proved to be extremely reliable in use. There is a free version of the
tools which restrict the size of code they will generate to 16KB. The full version can be evaluated free for 90
days.

The current configuration of the code is too large to fit within the 16K limit, however by removing some
features, e.g. Fat file system support then the free version may be sufficient.

A very useful feature of the IDE is the ability to use standard printf type functions and have the output
displayed in a console window within the IDE. In order for this to work the amount of memory set aside for
the stack and heap must be increased and the “cio” functionality must be enabled in the project build
configuration.

A small amount of source code in the platform common layer was taken from Plastic Logic’s equivalent
Linux drivers. The code uses anonymous unions extensively and in order to get the code to compile it was
necessary to add a compiler flag to tell it to behave more like gcc.

The shipped project configuration file has these settings changes made.

msp430-gcc
^^^^^^^^^^
There is an open source msp430 tool chain available for Linux – msp430-gcc. Some work has been done to
support this tool chain but the work is not yet complete. Much of the code compiles cleanly however there
are some issues related to pragmas used to declare interrupt handlers. Full support for this tool chain will
depend on customer demand.

MSP430 Specific Host Interfaces
===============================
GPIO Interface
--------------
This is the reference implementation for the GPIO host interface and can be found in msp430-gpio.c. It
supports the configuration of all features on all pins that can be configured. It is only possible to configure
one pin at a time in a port. It is not possible to define the configuration of multiple pins in a port with one
call – e.g. when defining an 8 bit bus as output or input. The code attempts to verify the request as much as
it can. Much of the error checking code can be disabled once the porting process to a new platform has
been completed and the platform configuration is stable.

I2C Interface
-------------
A single i2c interface is supported. I2C is only supported in UCSB modules and the chosen UCSB module is
defined in the msp430-i2c.c source file by setting the macros “USCI_UNIT” and “USCI_CHAN” as required.
The code will then reconfigure itself to reference the correct I2C unit. In addition to specifying which UCSI
module to use the I2C SDA and SCL pins need to be connected to the USCI unit by defining the appropriate
pins as PIN_SPECIAL in the gpio_request() call.

SPI Interface – Epson
---------------------
SPI is supported in both USCI_A and USCI_B modules and the chosen USCI module is defined in the
msp430-spi.c source file by setting the macros “USCI_UNIT” and “USCI_CHAN” as required. The code will
then reconfigure itself to reference the correct SPI unit. In addition to specifying which USCI module to use
the SPI_CLK, SPI_MOSI and SPI_MISO pins need to be connected to the USCI unit by defining the
appropriate pins as PIN_SPECIAL in the gpio_request() call. Note that it is possible to use both the USCI_A
and USCI_B units. i.e. USCI_A0 and USCI_B0 are physically different hardware units.

A single SPI interface is supported for Epson controller communications. Multiple controllers can be
connected to this bus and are selected using their chip select lines as required. This interface runs at
20Mbps reliably. Due to the need to keep the Epson chip selected for the duration of the image data
transfer the Epson controller must be placed on a separate bus to the SD card so that multiple blocks can
be read from the SD card.

SPI Interface – SD Card
-----------------------
SPI is supported in both USCI_A and USCI_B modules and the chosen USCI module is defined in the
msp430-sdcard.c source file by setting the macros “USCI_UNIT” and “USCI_CHAN” as required. The code
will then reconfigure itself to reference the correct SPI unit. In addition to specifying which USCI module to
use the SPI_CLK, SPI_MOSI and SPI_MISO pins need to be connected to the USCI unit by defining the
appropriate pins as PIN_SPECIAL in the gpio_request() call. Note that it is possible to use both the USCI_A
and USCI_B units. i.e. USCI_A0 and USCI_B0 are physically different hardware units.

A single SPI interface is supported for transferring data from the micro SD card slot. This interface runs at
20Mbps reliably.

UART Interface
--------------
A serial interface is supported using a pin header on the MSP430 board into which can be plugged an FTDI
active serial –to-USB cable. The code can be configured to route all standard output to the serial port rather
than back to the debugger. This allows debug output still be seen when no debugger is attached.

Porting the Existing Code to a New MSP430 Processor
---------------------------------------------------
Porting the existing code to a design which requires a different pin out is relatively straightforward. The
necessary configuration information is not centrally located and is kept close to the code it affects.

Define a new file that replaces the board setup file plat-ruddock2.c. This should define any required setup
for your platform but not the pins required by the reference code.

To reconfigure the reference code follow the sequence below:

1. Determine which USCI units will be used in the new configuration. Ensure the unit is suitable for its intended purpose.
2. Determine which pins are associated with the chosen USCI units.
3. Determine which pins will be used for the Epson SPI signals HRDY, HDC, and RESET
4. Determine which pin(s) will be used for the Epson SPI chip select
5. Determine which pins may be necessary to control the power supplies
6. In each of the msp430-spi.c, msp430-sdcard.c, msp430-i2c.c and msp430-uart.c

    a. Define USCI_UNIT and USCI_CHAN as required
    b. Modify the definitions for the pins so they match the chosen UCSI unit.
    c. E.g.:

.. code-block:: usci

    #define USCI_UNIT B
    #define USCI_CHAN 0
    // Pins from MSP430 connected to the SD Card
    #define SD_CS GPIO(5,5)
    #define SD_SIMO GPIO(3,1)
    #define SD_SOMI GPIO(3,2)
    #define SD_CLK GPIO(3,3)

7. In epson-if.c define the EPSON SPI interface signals E.g.:

.. code-block:: spi

    // Remaining Epson interface pins
    #define EPSON_HDC GPIO(1,3)
    #define EPSON_HRDY GPIO(2,7)
    #define EPSON_RESET GPIO(5,0)

8. In the platform implementation file, e.g. plat-hbz6.c, define the power control and Epson chip select pins. E.g.:

.. code-block:: plat

    #define B_HWSW_CTRL GPIO(1,2)
    #define B_POK GPIO(1,0)
    #define B_PMIC_EN GPIO(1,1)
    #define EPSON_CS_0 GPIO(3,6)
	
Recompile the code and it has now been retargeted to the new pin assignments.
