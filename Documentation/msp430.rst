Texas Instruments – MSP430
==========================

This section provides information specific to deploying the code on the reference MSP430 platform
hardware available from Plastic Logic. This provides a supported, stable environment in which to
investigate the behaviour of the code before moving on to a customised platform.

Parrot - MSP430 Processor Board
-------------------------------
The Parrot board docks with the Ruddock2 motherboard to provide access to the display interfaces. It has
the same form factor and connector pin out as a BeagleBone allowing the processors to be easily swapped
for evaluation or development work.

The board has the following features:

1. MSP430F5438A, clocked at 20MHz
2. A 32KHz oscillator for low power operation
3. micro SD card socket
4. On-board reset switch
5. JTAG programming header (an adapter may be required to mate with the MSP-FET430UIF programmer)
6. All 100 processor pins available on debug headers
7. On-board power regulation and power socket
8. The board has 1 LED for power good and another connected to a pin on the processor for status indication.
9. Provision for an SPI daisy-chain of MSP430 boards using 2 SPI channels (upstream and downstream)

If required the board can be used as a standalone development platform be powered from the JTAG-FET
programmer.


Toolchains
----------

Code Composer Studio
^^^^^^^^^^^^^^^^^^^^
This has been used extensively during development of the code in conjunction with the MSP-FET430UIF
USB/JTAG programmer. Both have proved to be extremely reliable in use. There is a free version of the
tools which restrict the size of code they will generate to 16KB. The full version can be evaluated free for 90
days.

The current configuration of the code is too large to fit within the 16K limit, however by removing some
features, e.g. Fat file system support then the free version may be sufficient.

A very useful feature of the IDE is the ability to use standard printf type functions and have the output
displayed in a console window within the IDE. In order for this to work the amount of memory set aside for
the stack and heap must be increased and the “cio” functionality must be enabled in the project build
configuration.

A small amount of source code in the platform common layer was taken from Plastic Logic’s equivalent
Linux drivers. The code uses anonymous unions extensively and in order to get the code to compile it was
necessary to add a compiler flag to tell it to behave more like gcc.

For full instructions on how to configure Code Composer Studio for the Plastic Logic reference code project
please see the chapter 11: Code Composer Studio Setup.


msp430-gcc
^^^^^^^^^^
There is an open source msp430 tool chain available – msp430-gcc. Some work has been done to support this tool 
chain but the work is not yet complete. Much of the code compiles cleanly however there are some issues related 
to pragmas used to declare interrupt handlers. Full support for this tool chain will depend on customer demand.


MSP430 Specific Host Interfaces
===============================
GPIO Interface
--------------
This is the reference implementation for the GPIO host interface and can be found in msp430-gpio.c. It
supports the configuration of all features on all pins that can be configured. It is only possible to configure
one pin at a time in a port. It is not possible to define the configuration of multiple pins in a port with one
call – e.g. when defining an 8 bit bus as output or input. The code attempts to verify the request as much as
it can. Much of the error checking code can be disabled once the porting process to a new platform has
been completed and the platform configuration is stable.


I2C Interface
-------------
A single i2c interface is supported. I2C is only supported in UCSB modules and the chosen UCSB module is
defined in the msp430-i2c.c source file by setting the macros “USCI_UNIT” and “USCI_CHAN” as required.
The code will then reconfigure itself to reference the correct I2C unit. In addition to specifying which UCSI
module to use the I2C SDA and SCL pins need to be connected to the USCI unit by defining the appropriate
pins as PIN_SPECIAL in the gpio_request() call.


SPI Interface – Epson
---------------------
SPI is supported in both USCI_A and USCI_B modules and the chosen USCI module is defined in the
msp430-spi.c source file by setting the macros “USCI_UNIT” and “USCI_CHAN” as required. The code will
then reconfigure itself to reference the correct SPI unit. In addition to specifying which USCI module to use
the SPI_CLK, SPI_MOSI and SPI_MISO pins need to be connected to the USCI unit by defining the
appropriate pins as PIN_SPECIAL in the gpio_request() call. Note that it is possible to use both the USCI_A
and USCI_B units. i.e. USCI_A0 and USCI_B0 are physically different hardware units.

A single SPI interface is supported for Epson controller communications. Multiple controllers can be
connected to this bus and are selected using their chip select lines as required. This interface runs at
20Mbps reliably. Due to the need to keep the Epson chip selected for the duration of the image data
transfer the Epson controller must be placed on a separate bus to the SD card so that multiple blocks can
be read from the SD card.


SPI Interface – SD Card
-----------------------
SPI is supported in both USCI_A and USCI_B modules and the chosen USCI module is defined in the
msp430-sdcard.c source file by setting the macros “USCI_UNIT” and “USCI_CHAN” as required. The code
will then reconfigure itself to reference the correct SPI unit. In addition to specifying which USCI module to
use the SPI_CLK, SPI_MOSI and SPI_MISO pins need to be connected to the USCI unit by defining the
appropriate pins as PIN_SPECIAL in the gpio_request() call. Note that it is possible to use both the USCI_A
and USCI_B units. i.e. USCI_A0 and USCI_B0 are physically different hardware units.

A single SPI interface is supported for transferring data from the micro SD card slot. This interface runs at
20Mbps reliably.

UART Interface
--------------
A serial interface is supported using a pin header on the MSP430 board into which can be plugged an FTDI
active serial –to-USB cable. The code can be configured to route all standard output to the serial port rather
than back to the debugger. This allows debug output still be seen when no debugger is attached.


Porting the Existing Code to a New MSP430 Processor
---------------------------------------------------
Porting the existing code to a design which requires a different pin out is relatively straightforward. The
necessary configuration information is not centrally located and is kept close to the code it affects.

Define a new file that replaces the board setup file plat-ruddock2.c. This should define any required setup
for your platform but not the pins required by the reference code.

To reconfigure the reference code follow the sequence below:

1. Determine which USCI units will be used in the new configuration. Ensure the unit is suitable for its intended purpose.
2. Determine which pins are associated with the chosen USCI units.
3. Determine which pins will be used for the Epson SPI signals HRDY, HDC, and RESET
4. Determine which pin(s) will be used for the Epson SPI chip select
5. Determine which pins may be necessary to control the power supplies
6. In each of the msp430-spi.c, msp430-sdcard.c, msp430-i2c.c and msp430-uart.c

    a. Define USCI_UNIT and USCI_CHAN as required
    b. Modify the definitions for the pins so they match the chosen UCSI unit.
    c. E.g.:

.. code-block:: usci

    #define USCI_UNIT B
    #define USCI_CHAN 0
    // Pins from MSP430 connected to the SD Card
    #define SD_CS GPIO(5,5)
    #define SD_SIMO GPIO(3,1)
    #define SD_SOMI GPIO(3,2)
    #define SD_CLK GPIO(3,3)

7. In epson-if.c define the Epson SPI interface signals E.g.:

.. code-block:: spi

    // Remaining Epson interface pins
    #define EPSON_HDC GPIO(1,3)
    #define EPSON_HRDY GPIO(2,7)
    #define EPSON_RESET GPIO(5,0)

8. In the platform implementation file, e.g. plat-hbz6.c, define the power control and Epson chip select pins. E.g.:

.. code-block:: plat

    #define B_HWSW_CTRL GPIO(1,2)
    #define B_POK GPIO(1,0)
    #define B_PMIC_EN GPIO(1,1)
    #define EPSON_CS_0 GPIO(3,6)
	
Recompile the code and it has now been retargeted to the new pin assignments.

.. raw:: pdf

   PageBreak
